<!--

   !!!!!!  WARNING: DO NOT EDIT THIS FILE!

   This file was generated from the Varnish VMOD source code.
   It will be automatically updated on each build.

-->
# Varnish Module (VMOD) `oidc`

OpenID Connect authentication for Varnish Cache.

This VMOD allows Varnish to act as an OpenID Connect Relying Party,
authenticating users against any OIDC-compliant identity provider
(Google, Microsoft Entra ID, Keycloak, Auth0, etc.) before serving
cached content.

## How it works

The VMOD implements the standard OIDC Authorization Code flow using a
built-in Varnish backend that generates redirect and error responses
directly — no `vcl_synth` state machine is needed:

1. An unauthenticated request arrives at a protected path.
2. VCL calls `session_valid()` which returns `FALSE` (no valid cookie).
3. VCL sets `req.backend_hint = provider.backend()` and returns `pass`.
4. The built-in backend generates a 302 redirect to the identity provider,
setting the state cookie automatically.
5. The user authenticates and is redirected back to the callback path.
6. VCL routes the callback to the same backend, which exchanges the code
for an ID token, validates it, and returns a 302 redirect with the
encrypted session cookie.
7. Subsequent requests include the session cookie; `session_valid()` returns
`TRUE` and individual claims are available via `claim()`.

## Session model

Sessions are **stateless and cookie-based**. The full set of ID token claims is
AES-256-GCM encrypted and stored directly in the cookie. No external session store
(Redis, memcached, etc.) is needed. Sessions survive Varnish restarts and work across
multiple Varnish instances sharing the same `cookie_secret`.

Session revocation is not supported in v1 — a session is valid until it expires.

## Security properties

- **Fail-closed**: all validation failures return empty string or `FALSE`. Partial
data is never leaked.
- **Issuer validation**: always enabled; the `iss` claim must match the discovery document.
- **Nonce binding**: the `nonce` in the ID token must match the nonce stored in the state cookie.
- **Cookie protection**: session and state cookies are `HttpOnly`, `SameSite=Lax`, `Path=/`,
and `Secure` by default. Contents are encrypted and authenticated with AES-256-GCM.
- **JWKS rotation**: unknown key IDs trigger an automatic JWKS refresh with exponential backoff.

## VCL example

```vcl
import oidc;
import std;

backend default {
.host = "127.0.0.1";
.port = "8080";
}

sub vcl_init {
new google = oidc.provider(
discovery_url = "https://accounts.google.com/.well-known/openid-configuration",
client_id     = std.getenv("OIDC_CLIENT_ID"),
client_secret = std.getenv("OIDC_CLIENT_SECRET"),
redirect_uri  = "https://www.example.com/oidc/callback",
cookie_secret = std.getenv("OIDC_JWT_SECRET"),
scopes        = "openid email profile"
);
}

sub vcl_recv {
if (req.url ~ "^/oidc/callback") {
set req.backend_hint = google.backend();
return (pass);
}
if (req.url ~ "^/app/") {
if (!google.session_valid()) {
set req.backend_hint = google.backend();
return (pass);
}
set req.http.X-User-Email = google.claim("email");
}
}
// No vcl_synth needed!
```

```vcl
// Place import statement at the top of your VCL file
// This loads vmod from a standard location
import oidc;

// Or load vmod from a specific file
import oidc from "path/to/liboidc.so";
```

### Constructor `oidc.provider(STRING discovery_url, STRING client_id, STRING client_secret, STRING redirect_uri, STRING cookie_secret, [STRING cookie_name], [DURATION cookie_ttl], [DURATION state_cookie_ttl], [BOOL cookie_secure], [STRING scopes])`

Create a new OIDC provider by fetching and validating the discovery document
and JWKS from the identity provider. This is called during `vcl_init`.

If the discovery document or JWKS cannot be fetched, initialization fails
and Varnish will not start (fail-closed).

The `cookie_secret` must decode to exactly 32 bytes. It accepts hex,
base64, or base64url encoding. Generate one with:
`openssl rand -hex 32`

* `STRING discovery_url`:
The OIDC discovery endpoint URL, typically ending in
`/.well-known/openid-configuration`.
* `STRING client_id`:
The OAuth 2.0 client ID registered with the identity provider.
* `STRING client_secret`:
The OAuth 2.0 client secret registered with the identity provider.
* `STRING redirect_uri`:
The absolute URL the provider will redirect to after authentication.
Must match the redirect URI registered with the provider.
* `STRING cookie_secret`:
A 32-byte secret used for AES-256-GCM encryption of session and
state cookies. Accepts hex, base64, or base64url encoding.
* `[STRING cookie_name]`:
Name of the session cookie. Defaults to `__oidc`.
* `[DURATION cookie_ttl]`:
Session cookie lifetime. Defaults to 1 hour.
* `[DURATION state_cookie_ttl]`:
State cookie lifetime (used during the login flow). Defaults to 5 minutes.
* `[BOOL cookie_secure]`:
Whether to set the `Secure` flag on cookies. Defaults to `true`.
Set to `false` only for local development over plain HTTP.
* `[STRING scopes]`:
Space-separated list of OAuth scopes to request. Defaults to `"openid"`.
Common additions: `"openid email profile"`.

#### Method `BACKEND <object>.backend()`

Returns the built-in OIDC backend that generates redirect and error
responses directly. Use this as `req.backend_hint` in `vcl_recv` for:

- **Callback requests** (`/oidc/callback`): validates the state cookie,
exchanges the authorization code for a session, and redirects the user
back to the original URL with a `Set-Cookie` header.
- **Login redirects**: generates a 302 redirect to the identity provider's
authorization endpoint with the appropriate state cookie.

The backend determines whether a request is a callback or a login redirect
by comparing the request path against the configured `redirect_uri` path.

#### Method `BOOL <object>.session_valid()`

Returns `TRUE` if the request carries a valid, non-expired session cookie.

Use this in `vcl_recv` to decide whether a request is authenticated.
Returns `FALSE` if the cookie is missing, expired, tampered with, or
encrypted with a different key.

#### Method `STRING <object>.claim(STRING name)`

Returns the value of a named claim from the session cookie.

String and numeric claims are returned as plain strings. Array and
object claims are returned as compact JSON. Returns an empty string
if the session is invalid or the claim does not exist.

```vcl
set req.http.X-User-Email = google.claim("email");
set req.http.X-User-Sub   = google.claim("sub");
```

* `STRING name`:
The claim name to look up (e.g., `"email"`, `"sub"`, `"name"`).

#### Method `STRING <object>.authorization_url()`

Returns the full authorization URL to redirect the user to the identity
provider. As a side effect, sets a short-lived state cookie on the response
containing the CSRF state token, nonce, and the return-to path.

Call this in `vcl_synth` when an unauthenticated user needs to log in,
and use the returned URL as the `Location` header for a 302 redirect.

Returns an empty string on internal error (e.g., failed to set the
state cookie on the response).

#### Method `STRING <object>.callback_code()`

Extracts the `code` query parameter from the current callback request URL.

Returns an empty string if the parameter is missing.

#### Method `STRING <object>.callback_state()`

Extracts the `state` query parameter from the current callback request URL.

Returns an empty string if the parameter is missing.

#### Method `BOOL <object>.callback_state_valid()`

Validates the OIDC callback by checking that the `state` query parameter
matches the value stored in the encrypted state cookie.

Returns `FALSE` if the state cookie is missing, expired, tampered with,
or does not match the `state` parameter. This is a CSRF protection check
and should be called before `exchange_code_for_session()`.

#### Method `STRING <object>.exchange_code_for_session(STRING code)`

Exchanges an authorization code for an ID token, validates the token,
and returns a `Set-Cookie` header value containing the encrypted session.

This method performs the following steps:
1. Validates the state cookie (CSRF check).
2. POSTs the authorization code to the provider's token endpoint.
3. Validates the returned ID token (signature, issuer, audience, expiry, nonce).
4. Encrypts the ID token claims into a session cookie.

Returns an empty string on any failure (network error, invalid token,
state mismatch, etc.). The VCL should check for an empty return value
and respond with a 403 or similar error.

The returned string is a complete `Set-Cookie` header value that should
be set on the response (e.g., `set resp.http.Set-Cookie = ...`).

* `STRING code`:
The authorization code from the callback query string.
Typically obtained via `callback_code()`.

#### Method `STRING <object>.callback_redirect_target()`

Returns the original URL path the user was trying to access before
being redirected to log in. This is extracted from the encrypted state
cookie that was set during `authorization_url()`.

Returns `"/"` if the state is invalid, expired, or the stored path
fails validation (e.g., contains a scheme/host or exceeds 2048 bytes).

Use this as the `Location` header when redirecting the user after
successful authentication.
