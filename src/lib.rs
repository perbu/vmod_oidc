mod crypto;
mod error;
mod helpers;
mod jwks;

#[cfg(feature = "vmod")]
mod vmod;

pub use error::OidcError;

pub(crate) use crypto::{CookieCipher, StateCookie, decode_cookie_secret};
pub(crate) use helpers::{
    build_set_cookie, cookie_value, derive_return_to, now_secs, query_param, random_token,
    validate_return_to, MAX_CLAIMS_BYTES,
};
pub(crate) use jwks::{
    DiscoveryDocument, JwksCache, RsaKeyMaterial, TokenResponse, fetch_discovery, fetch_jwks_cache,
};

use jsonwebtoken::{Algorithm, DecodingKey, Validation, decode, decode_header};
use reqwest::blocking::Client;
use serde_json::{Map, Value};
use std::cmp;
use std::collections::HashSet;
use std::sync::Mutex;
use std::time::Duration;
use url::Url;

const DEFAULT_COOKIE_NAME: &str = "__oidc";
const DEFAULT_STATE_COOKIE_NAME: &str = "__oidc_state";
const DEFAULT_SCOPES: &str = "openid";
const DEFAULT_COOKIE_TTL_SECS: u64 = 3600;
const DEFAULT_STATE_COOKIE_TTL_SECS: u64 = 300;

#[derive(Debug, Clone)]
pub struct ProviderConfig {
    pub discovery_url: String,
    pub client_id: String,
    pub client_secret: String,
    pub redirect_uri: String,
    pub cookie_secret: String,
    pub cookie_name: String,
    pub state_cookie_name: String,
    pub cookie_ttl_secs: u64,
    pub state_cookie_ttl_secs: u64,
    pub cookie_secure: bool,
    pub scopes: String,
}

impl ProviderConfig {
    pub fn normalize(mut self) -> Result<Self, OidcError> {
        if self.discovery_url.trim().is_empty() {
            return Err(OidcError::InvalidConfig(
                "discovery_url is required".to_string(),
            ));
        }
        if self.client_id.trim().is_empty() {
            return Err(OidcError::InvalidConfig(
                "client_id is required".to_string(),
            ));
        }
        if self.client_secret.trim().is_empty() {
            return Err(OidcError::InvalidConfig(
                "client_secret is required".to_string(),
            ));
        }
        if self.redirect_uri.trim().is_empty() {
            return Err(OidcError::InvalidConfig(
                "redirect_uri is required".to_string(),
            ));
        }
        if self.cookie_secret.trim().is_empty() {
            return Err(OidcError::InvalidConfig(
                "cookie_secret is required".to_string(),
            ));
        }

        if self.cookie_name.trim().is_empty() {
            self.cookie_name = DEFAULT_COOKIE_NAME.to_string();
        }
        if self.state_cookie_name.trim().is_empty() {
            self.state_cookie_name = if self.cookie_name == DEFAULT_COOKIE_NAME {
                DEFAULT_STATE_COOKIE_NAME.to_string()
            } else {
                format!("{}_state", self.cookie_name)
            };
        }
        if self.scopes.trim().is_empty() {
            self.scopes = DEFAULT_SCOPES.to_string();
        }
        if self.cookie_ttl_secs == 0 {
            self.cookie_ttl_secs = DEFAULT_COOKIE_TTL_SECS;
        }
        if self.state_cookie_ttl_secs == 0 {
            self.state_cookie_ttl_secs = DEFAULT_STATE_COOKIE_TTL_SECS;
        }

        Ok(self)
    }
}

impl Default for ProviderConfig {
    fn default() -> Self {
        Self {
            discovery_url: String::new(),
            client_id: String::new(),
            client_secret: String::new(),
            redirect_uri: String::new(),
            cookie_secret: String::new(),
            cookie_name: DEFAULT_COOKIE_NAME.to_string(),
            state_cookie_name: DEFAULT_STATE_COOKIE_NAME.to_string(),
            cookie_ttl_secs: DEFAULT_COOKIE_TTL_SECS,
            state_cookie_ttl_secs: DEFAULT_STATE_COOKIE_TTL_SECS,
            cookie_secure: true,
            scopes: DEFAULT_SCOPES.to_string(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct AuthorizationStart {
    pub url: String,
    pub state_set_cookie: String,
}

/// The response generated by `handle_backend_request()` for the Varnish backend.
#[derive(Debug)]
pub enum OidcBackendResponse {
    /// Redirect the user to the identity provider's authorization endpoint.
    LoginRedirect {
        location: String,
        state_set_cookie: String,
    },
    /// Redirect the user back to the original URL after successful authentication.
    CallbackSuccess {
        location: String,
        session_set_cookie: String,
    },
    /// An error occurred during the OIDC flow.
    Error { status: u16 },
}

pub struct Provider {
    config: ProviderConfig,
    client: Client,
    discovery: DiscoveryDocument,
    cookie_cipher: CookieCipher,
    jwks_cache: Mutex<JwksCache>,
    redirect_uri_path: String,
}

impl Provider {
    pub fn new(config: ProviderConfig) -> Result<Self, OidcError> {
        let config = config.normalize()?;
        let cookie_key = decode_cookie_secret(&config.cookie_secret)?;

        let redirect_uri_path = Url::parse(&config.redirect_uri)
            .map(|u| u.path().to_string())
            .map_err(|e| {
                OidcError::InvalidConfig(format!("redirect_uri is not a valid URL: {e}"))
            })?;

        let client = Client::builder()
            .connect_timeout(Duration::from_secs(2))
            .timeout(Duration::from_secs(5))
            .build()?;

        let discovery = fetch_discovery(&client, &config.discovery_url)?;
        let jwks_cache = fetch_jwks_cache(&client, &discovery.jwks_uri)?;

        Ok(Self {
            config,
            client,
            discovery,
            cookie_cipher: CookieCipher::new(cookie_key),
            jwks_cache: Mutex::new(jwks_cache),
            redirect_uri_path,
        })
    }

    /// Returns the path component of the configured redirect URI.
    pub fn redirect_uri_path(&self) -> &str {
        &self.redirect_uri_path
    }

    pub fn authorization_url(
        &self,
        current_request_url: &str,
    ) -> Result<AuthorizationStart, OidcError> {
        let state = random_token(32);
        let nonce = random_token(32);
        let return_to = derive_return_to(current_request_url);

        let state_cookie = StateCookie {
            state: state.clone(),
            nonce,
            exp: now_secs() + self.config.state_cookie_ttl_secs,
            return_to,
        };

        let state_cookie_value = self.cookie_cipher.encrypt_json(&state_cookie)?;
        let state_set_cookie = build_set_cookie(
            &self.config.state_cookie_name,
            &state_cookie_value,
            self.config.state_cookie_ttl_secs,
            self.config.cookie_secure,
        );

        let mut auth_url = Url::parse(&self.discovery.authorization_endpoint)?;
        auth_url
            .query_pairs_mut()
            .append_pair("response_type", "code")
            .append_pair("client_id", &self.config.client_id)
            .append_pair("redirect_uri", &self.config.redirect_uri)
            .append_pair("scope", &self.config.scopes)
            .append_pair("state", &state)
            .append_pair("nonce", &state_cookie.nonce);

        Ok(AuthorizationStart {
            url: auth_url.to_string(),
            state_set_cookie,
        })
    }

    /// Handle a backend request for the OIDC flow. Determines whether the
    /// request is a callback or a login redirect based on the URL path, and
    /// returns the appropriate response.
    pub fn handle_backend_request(
        &self,
        url: &str,
        cookie_header: Option<&str>,
    ) -> OidcBackendResponse {
        let path = url.split('?').next().unwrap_or(url);

        if path == self.redirect_uri_path {
            // Callback path: validate state, exchange code, redirect to return-to
            let code = self.callback_code(url);
            if code.is_empty() {
                return OidcBackendResponse::Error { status: 403 };
            }
            if !self.callback_state_valid(url, cookie_header) {
                return OidcBackendResponse::Error { status: 403 };
            }
            let session_cookie =
                self.exchange_code_for_session(&code, url, cookie_header);
            if session_cookie.is_empty() {
                return OidcBackendResponse::Error { status: 403 };
            }
            let location = self.callback_redirect_target(url, cookie_header);
            OidcBackendResponse::CallbackSuccess {
                location,
                session_set_cookie: session_cookie,
            }
        } else {
            // Login redirect path: generate authorization URL
            match self.authorization_url(url) {
                Ok(start) => OidcBackendResponse::LoginRedirect {
                    location: start.url,
                    state_set_cookie: start.state_set_cookie,
                },
                Err(_) => OidcBackendResponse::Error { status: 500 },
            }
        }
    }

    pub fn callback_code(&self, callback_url: &str) -> String {
        query_param(callback_url, "code").unwrap_or_default()
    }

    pub fn callback_state(&self, callback_url: &str) -> String {
        query_param(callback_url, "state").unwrap_or_default()
    }

    pub fn callback_state_valid(&self, callback_url: &str, cookie_header: Option<&str>) -> bool {
        self.load_valid_state(callback_url, cookie_header).is_ok()
    }

    pub fn callback_redirect_target(
        &self,
        callback_url: &str,
        cookie_header: Option<&str>,
    ) -> String {
        self.load_valid_state(callback_url, cookie_header)
            .map(|state| validate_return_to(&state.return_to))
            .unwrap_or_else(|_| "/".to_string())
    }

    pub fn exchange_code_for_session(
        &self,
        code: &str,
        callback_url: &str,
        cookie_header: Option<&str>,
    ) -> String {
        self.exchange_code_for_session_result(code, callback_url, cookie_header)
            .unwrap_or_default()
    }

    pub fn session_valid(&self, cookie_header: Option<&str>) -> bool {
        self.load_session_claims(cookie_header).is_ok()
    }

    pub fn claim(&self, cookie_header: Option<&str>, name: &str) -> String {
        match self.load_session_claims(cookie_header) {
            Ok(claims) => match claims.get(name) {
                Some(Value::String(s)) => s.clone(),
                Some(Value::Number(n)) => n.to_string(),
                Some(Value::Bool(v)) => v.to_string(),
                Some(Value::Array(v)) => serde_json::to_string(v).unwrap_or_default(),
                Some(Value::Object(v)) => serde_json::to_string(v).unwrap_or_default(),
                _ => String::new(),
            },
            Err(_) => String::new(),
        }
    }

    pub fn create_session_cookie_from_claims(&self, claims: &Value) -> Result<String, OidcError> {
        let bytes = serde_json::to_vec(claims)?;
        if bytes.len() > MAX_CLAIMS_BYTES {
            return Err(OidcError::InvalidToken(
                "serialized claims exceeds 3072 bytes".to_string(),
            ));
        }

        let value = self.cookie_cipher.encrypt_json(claims)?;
        Ok(build_set_cookie(
            &self.config.cookie_name,
            &value,
            self.config.cookie_ttl_secs,
            self.config.cookie_secure,
        ))
    }

    fn exchange_code_for_session_result(
        &self,
        code: &str,
        callback_url: &str,
        cookie_header: Option<&str>,
    ) -> Result<String, OidcError> {
        if code.trim().is_empty() {
            return Err(OidcError::InvalidToken(
                "missing authorization code".to_string(),
            ));
        }

        let state = self.load_valid_state(callback_url, cookie_header)?;
        let id_token = self.exchange_for_id_token(code)?;
        let claims = self.validate_id_token(&id_token, &state.nonce)?;

        self.create_session_cookie_from_claims(&claims)
    }

    fn exchange_for_id_token(&self, code: &str) -> Result<String, OidcError> {
        let response = self
            .client
            .post(&self.discovery.token_endpoint)
            .form(&[
                ("grant_type", "authorization_code"),
                ("code", code),
                ("redirect_uri", self.config.redirect_uri.as_str()),
                ("client_id", self.config.client_id.as_str()),
                ("client_secret", self.config.client_secret.as_str()),
            ])
            .send()?;

        if !response.status().is_success() {
            return Err(OidcError::InvalidToken(format!(
                "token endpoint returned {}",
                response.status()
            )));
        }

        let token_response: TokenResponse = response.json()?;
        token_response
            .id_token
            .ok_or_else(|| OidcError::InvalidToken("token response missing id_token".to_string()))
    }

    fn validate_id_token(&self, id_token: &str, expected_nonce: &str) -> Result<Value, OidcError> {
        self.refresh_jwks_if_expired()?;

        let header = decode_header(id_token)?;
        if header.alg != Algorithm::RS256 {
            return Err(OidcError::InvalidToken(
                "only RS256 is supported in v1".to_string(),
            ));
        }

        let key = self.decoding_key_for_kid(header.kid.as_deref())?;

        let mut validation = Validation::new(Algorithm::RS256);
        validation.set_issuer(&[self.discovery.issuer.as_str()]);
        validation.set_audience(&[self.config.client_id.as_str()]);
        validation.required_spec_claims = HashSet::from([
            "exp".to_string(),
            "iat".to_string(),
            "aud".to_string(),
            "iss".to_string(),
        ]);

        let token_data = decode::<Value>(id_token, &key, &validation)?;

        let nonce = token_data
            .claims
            .get("nonce")
            .and_then(Value::as_str)
            .ok_or_else(|| OidcError::InvalidToken("nonce claim missing".to_string()))?;
        let sub = token_data
            .claims
            .get("sub")
            .and_then(Value::as_str)
            .ok_or_else(|| OidcError::InvalidToken("sub claim missing".to_string()))?;

        if nonce != expected_nonce {
            return Err(OidcError::InvalidToken("nonce mismatch".to_string()));
        }
        if sub.is_empty() {
            return Err(OidcError::InvalidToken("sub claim missing".to_string()));
        }

        Ok(token_data.claims)
    }

    fn refresh_jwks_if_expired(&self) -> Result<(), OidcError> {
        let expired = {
            let cache = self
                .jwks_cache
                .lock()
                .map_err(|_| OidcError::Internal("jwks mutex poisoned".to_string()))?;
            now_secs() >= cache.expires_at
        };

        if expired {
            self.refresh_jwks(true)?;
        }

        Ok(())
    }

    fn refresh_jwks(&self, required_for_request: bool) -> Result<(), OidcError> {
        let now = now_secs();
        let prev_expires_at;
        {
            let cache = self
                .jwks_cache
                .lock()
                .map_err(|_| OidcError::Internal("jwks mutex poisoned".to_string()))?;

            if now < cache.backoff_until {
                return Err(OidcError::InvalidToken(
                    "jwks refresh in backoff window".to_string(),
                ));
            }

            if !required_for_request && now < cache.expires_at {
                return Ok(());
            }

            prev_expires_at = cache.expires_at;
        }

        match fetch_jwks_cache(&self.client, &self.discovery.jwks_uri) {
            Ok(new_cache) => {
                let mut cache = self
                    .jwks_cache
                    .lock()
                    .map_err(|_| OidcError::Internal("jwks mutex poisoned".to_string()))?;
                // Only update if no other thread refreshed while we were fetching.
                if cache.expires_at == prev_expires_at {
                    *cache = new_cache;
                }
                Ok(())
            }
            Err(err) => {
                let mut cache = self
                    .jwks_cache
                    .lock()
                    .map_err(|_| OidcError::Internal("jwks mutex poisoned".to_string()))?;
                // Only set backoff if no other thread refreshed successfully.
                if cache.expires_at == prev_expires_at {
                    let exponent = cmp::min(cache.refresh_failures, 6);
                    let backoff = 1u64 << exponent;
                    cache.refresh_failures = cache.refresh_failures.saturating_add(1);
                    cache.backoff_until = now_secs() + cmp::min(backoff, 60);
                }
                Err(err)
            }
        }
    }

    fn decoding_key_for_kid(&self, kid: Option<&str>) -> Result<DecodingKey, OidcError> {
        if let Some(key) = self.lookup_key(kid)? {
            return DecodingKey::from_rsa_components(&key.n, &key.e)
                .map_err(|e| OidcError::InvalidToken(format!("invalid jwk: {e}")));
        }

        self.refresh_jwks(true)?;

        if let Some(key) = self.lookup_key(kid)? {
            return DecodingKey::from_rsa_components(&key.n, &key.e)
                .map_err(|e| OidcError::InvalidToken(format!("invalid jwk: {e}")));
        }

        Err(OidcError::InvalidToken(
            "no matching jwk found for token kid".to_string(),
        ))
    }

    fn lookup_key(&self, kid: Option<&str>) -> Result<Option<RsaKeyMaterial>, OidcError> {
        let cache = self
            .jwks_cache
            .lock()
            .map_err(|_| OidcError::Internal("jwks mutex poisoned".to_string()))?;

        Ok(cache.lookup(kid))
    }

    fn load_valid_state(
        &self,
        callback_url: &str,
        cookie_header: Option<&str>,
    ) -> Result<StateCookie, OidcError> {
        let expected_state = self.callback_state(callback_url);
        if expected_state.is_empty() {
            return Err(OidcError::InvalidState);
        }

        let raw_state_cookie = cookie_value(cookie_header, &self.config.state_cookie_name)
            .ok_or(OidcError::InvalidState)?;

        let state: StateCookie = self.cookie_cipher.decrypt_json(raw_state_cookie)?;
        if state.exp <= now_secs() {
            return Err(OidcError::InvalidState);
        }

        if state.state != expected_state {
            return Err(OidcError::InvalidState);
        }

        Ok(state)
    }

    fn load_session_claims(
        &self,
        cookie_header: Option<&str>,
    ) -> Result<Map<String, Value>, OidcError> {
        let raw_cookie = cookie_value(cookie_header, &self.config.cookie_name)
            .ok_or_else(|| OidcError::InvalidToken("session cookie missing".to_string()))?;
        let claims: Value = self.cookie_cipher.decrypt_json(raw_cookie)?;
        let Value::Object(obj) = claims else {
            return Err(OidcError::InvalidToken(
                "claims payload must be an object".to_string(),
            ));
        };

        let exp = obj
            .get("exp")
            .and_then(Value::as_i64)
            .ok_or_else(|| OidcError::InvalidToken("exp claim missing".to_string()))?;

        if exp <= now_secs() as i64 {
            return Err(OidcError::InvalidToken("session expired".to_string()));
        }

        Ok(obj)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use jsonwebtoken::{Algorithm, EncodingKey, Header, encode};
    use mockito::Matcher;
    use serde_json::{Value, json};

    const TEST_SECRET_HEX: &str =
        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    const FIXTURE_RSA_PRIVATE_PEM: &str = include_str!("../tests/fixtures/test-keys/rsa-private.pem");
    const FIXTURE_WRONG_RSA_PRIVATE_PEM: &str =
        include_str!("../tests/fixtures/test-keys/wrong-key-private.pem");
    const FIXTURE_JWKS_JSON: &str = include_str!("../tests/fixtures/test-keys/jwks.json");

    fn test_config(discovery_url: String) -> ProviderConfig {
        ProviderConfig {
            discovery_url,
            client_id: "client-123".to_string(),
            client_secret: "secret-xyz".to_string(),
            redirect_uri: "https://example.test/oidc/callback".to_string(),
            cookie_secret: TEST_SECRET_HEX.to_string(),
            cookie_name: "__oidc_test".to_string(),
            state_cookie_name: "__oidc_state_test".to_string(),
            cookie_ttl_secs: 3600,
            state_cookie_ttl_secs: 300,
            cookie_secure: true,
            scopes: "openid email profile".to_string(),
        }
    }

    fn setup_provider_server() -> (mockito::ServerGuard, Provider) {
        let mut server = mockito::Server::new();

        let discovery_path = "/.well-known/openid-configuration";
        let jwks_path = "/jwks";
        let token_path = "/token";

        server
            .mock("GET", discovery_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(format!(
                "{{\"issuer\":\"{}\",\"authorization_endpoint\":\"{}/authorize\",\"token_endpoint\":\"{}{}\",\"jwks_uri\":\"{}{}\"}}",
                server.url(),
                server.url(),
                server.url(),
                token_path,
                server.url(),
                jwks_path
            ))
            .create();

        server
            .mock("GET", jwks_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_header("cache-control", "max-age=120")
            .with_body(
                "{\"keys\":[{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"test-key\",\"n\":\"AQAB\",\"e\":\"AQAB\"}]}",
            )
            .create();

        let provider = Provider::new(test_config(format!("{}{}", server.url(), discovery_path)))
            .expect("provider should initialize");

        (server, provider)
    }

    fn setup_provider_server_with_fixture_jwks() -> (mockito::ServerGuard, Provider, String) {
        let mut server = mockito::Server::new();
        let discovery_path = "/.well-known/openid-configuration";
        let jwks_path = "/jwks";
        let token_path = "/token";

        server
            .mock("GET", discovery_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(format!(
                "{{\"issuer\":\"{}\",\"authorization_endpoint\":\"{}/authorize\",\"token_endpoint\":\"{}{}\",\"jwks_uri\":\"{}{}\"}}",
                server.url(),
                server.url(),
                server.url(),
                token_path,
                server.url(),
                jwks_path
            ))
            .create();

        server
            .mock("GET", jwks_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(FIXTURE_JWKS_JSON)
            .create();

        let provider = Provider::new(test_config(format!("{}{}", server.url(), discovery_path)))
            .expect("provider should initialize");

        (server, provider, token_path.to_string())
    }

    fn cookie_pair_from_set_cookie(set_cookie: &str) -> String {
        set_cookie
            .split(';')
            .next()
            .expect("set-cookie should contain name=value")
            .trim()
            .to_string()
    }

    fn sign_token_with_claims(claims: &Value, private_pem: &str, kid: &str) -> String {
        let mut header = Header::new(Algorithm::RS256);
        header.kid = Some(kid.to_string());
        let key = EncodingKey::from_rsa_pem(private_pem.as_bytes()).expect("valid rsa private key");
        encode(&header, claims, &key).expect("token should be signed")
    }

    fn exchange_with_signed_token<F>(token_builder: F) -> String
    where
        F: FnOnce(&str, &str) -> String,
    {
        let (mut server, provider, token_path) = setup_provider_server_with_fixture_jwks();
        let start = provider
            .authorization_url("/protected?x=1")
            .expect("auth start should work");
        let state = query_param(&start.url, "state").expect("state must exist");
        let nonce = query_param(&start.url, "nonce").expect("nonce must exist");

        let token = token_builder(&nonce, &server.url());
        let token_body = format!(
            "{{\"id_token\":\"{token}\",\"access_token\":\"abc\",\"token_type\":\"Bearer\"}}"
        );

        let token_mock = server
            .mock("POST", token_path.as_str())
            .match_header(
                "content-type",
                Matcher::Regex("application/x-www-form-urlencoded.*".to_string()),
            )
            .match_body(Matcher::UrlEncoded(
                "grant_type".into(),
                "authorization_code".into(),
            ))
            .match_body(Matcher::UrlEncoded("code".into(), "auth-code".into()))
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(token_body)
            .create();

        let callback_url = format!("/oidc/callback?code=auth-code&state={state}");
        let cookie_header = cookie_pair_from_set_cookie(&start.state_set_cookie);
        let result =
            provider.exchange_code_for_session("auth-code", &callback_url, Some(&cookie_header));
        token_mock.assert();
        result
    }

    #[test]
    fn authorization_url_sets_state_cookie_and_callback_state_validates() {
        let (_server, provider) = setup_provider_server();

        let start = provider
            .authorization_url("https://example.test/protected/data?x=1#frag")
            .expect("authorization_url should succeed");

        assert!(start.url.contains("response_type=code"));
        assert!(start.url.contains("client_id=client-123"));
        assert!(
            start
                .url
                .contains("redirect_uri=https%3A%2F%2Fexample.test%2Foidc%2Fcallback")
        );
        assert!(start.url.contains("scope=openid+email+profile"));

        assert!(start.state_set_cookie.contains("HttpOnly"));
        assert!(start.state_set_cookie.contains("SameSite=Lax"));
        assert!(start.state_set_cookie.contains("Path=/"));
        assert!(start.state_set_cookie.contains("Secure"));

        let state = query_param(&start.url, "state").expect("state must exist");
        let callback_url = format!("/oidc/callback?code=abc&state={state}");
        let cookie_header = cookie_pair_from_set_cookie(&start.state_set_cookie);

        assert!(provider.callback_state_valid(&callback_url, Some(&cookie_header)));
        assert_eq!(
            provider.callback_redirect_target(&callback_url, Some(&cookie_header)),
            "/protected/data?x=1"
        );

        assert!(
            !provider
                .callback_state_valid("/oidc/callback?code=abc&state=wrong", Some(&cookie_header))
        );
        assert_eq!(
            provider.callback_redirect_target(
                "/oidc/callback?code=abc&state=wrong",
                Some(&cookie_header)
            ),
            "/"
        );
    }

    #[test]
    fn session_cookie_roundtrip_and_claim_readback() {
        let (_server, provider) = setup_provider_server();

        let claims = serde_json::json!({
            "sub": "123",
            "email": "user@example.test",
            "roles": ["admin", "viewer"],
            "profile": {"name": "User"},
            "iat": now_secs() as i64,
            "exp": (now_secs() + 60) as i64
        });

        let set_cookie = provider
            .create_session_cookie_from_claims(&claims)
            .expect("session cookie should be created");
        let cookie_header = cookie_pair_from_set_cookie(&set_cookie);

        assert!(provider.session_valid(Some(&cookie_header)));
        assert_eq!(
            provider.claim(Some(&cookie_header), "email"),
            "user@example.test"
        );
        assert_eq!(provider.claim(Some(&cookie_header), "sub"), "123");
        assert_eq!(
            provider.claim(Some(&cookie_header), "roles"),
            "[\"admin\",\"viewer\"]"
        );
        assert_eq!(
            provider.claim(Some(&cookie_header), "profile"),
            "{\"name\":\"User\"}"
        );
        assert_eq!(provider.claim(Some(&cookie_header), "missing"), "");

        let expired_claims = serde_json::json!({
            "sub": "123",
            "iat": now_secs() as i64,
            "exp": (now_secs() - 1) as i64
        });
        let expired_cookie = provider
            .create_session_cookie_from_claims(&expired_claims)
            .expect("expired cookie still serializes");
        let expired_header = cookie_pair_from_set_cookie(&expired_cookie);
        assert!(!provider.session_valid(Some(&expired_header)));
    }

    #[test]
    fn exchange_code_failure_returns_empty_string() {
        let mut server = mockito::Server::new();

        let discovery_path = "/.well-known/openid-configuration";
        let jwks_path = "/jwks";
        let token_path = "/token";

        server
            .mock("GET", discovery_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(format!(
                "{{\"issuer\":\"{}\",\"authorization_endpoint\":\"{}/authorize\",\"token_endpoint\":\"{}{}\",\"jwks_uri\":\"{}{}\"}}",
                server.url(),
                server.url(),
                server.url(),
                token_path,
                server.url(),
                jwks_path
            ))
            .create();

        server
            .mock("GET", jwks_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(
                "{\"keys\":[{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"test-key\",\"n\":\"AQAB\",\"e\":\"AQAB\"}]}",
            )
            .create();

        let token_mock = server
            .mock("POST", token_path)
            .match_header(
                "content-type",
                Matcher::Regex("application/x-www-form-urlencoded.*".to_string()),
            )
            .match_body(Matcher::AllOf(vec![
                Matcher::UrlEncoded("grant_type".into(), "authorization_code".into()),
                Matcher::UrlEncoded("code".into(), "abc123".into()),
                Matcher::UrlEncoded("client_id".into(), "client-123".into()),
                Matcher::UrlEncoded("client_secret".into(), "secret-xyz".into()),
                Matcher::UrlEncoded(
                    "redirect_uri".into(),
                    "https://example.test/oidc/callback".into(),
                ),
            ]))
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body("{\"access_token\":\"abc\"}")
            .create();

        let provider = Provider::new(test_config(format!("{}{}", server.url(), discovery_path)))
            .expect("provider should initialize");

        let start = provider
            .authorization_url("/protected")
            .expect("auth start should work");

        let state = query_param(&start.url, "state").expect("state must exist");
        let callback_url = format!("/oidc/callback?code=abc123&state={state}");
        let cookie_header = cookie_pair_from_set_cookie(&start.state_set_cookie);

        let result =
            provider.exchange_code_for_session("abc123", &callback_url, Some(&cookie_header));
        assert_eq!(result, "");
        token_mock.assert();
    }

    #[test]
    fn invalid_return_to_falls_back_to_root_without_invalidating_state() {
        let (_server, provider) = setup_provider_server();
        let state = "state-abc";
        let callback_url = "/oidc/callback?code=abc&state=state-abc";

        let state_cookie = StateCookie {
            state: state.to_string(),
            nonce: "nonce-abc".to_string(),
            exp: now_secs() + 60,
            return_to: "https://evil.test/steal".to_string(),
        };

        let value = provider
            .cookie_cipher
            .encrypt_json(&state_cookie)
            .expect("state cookie should encrypt");
        let cookie_header = format!("{}={value}", provider.config.state_cookie_name);

        assert!(provider.callback_state_valid(callback_url, Some(&cookie_header)));
        assert_eq!(
            provider.callback_redirect_target(callback_url, Some(&cookie_header)),
            "/"
        );
    }

    #[test]
    fn provider_init_fails_for_invalid_cookie_secret() {
        let mut server = mockito::Server::new();

        let discovery_path = "/.well-known/openid-configuration";
        let jwks_path = "/jwks";

        server
            .mock("GET", discovery_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(format!(
                "{{\"issuer\":\"{}\",\"authorization_endpoint\":\"{}/authorize\",\"token_endpoint\":\"{}/token\",\"jwks_uri\":\"{}{}\"}}",
                server.url(),
                server.url(),
                server.url(),
                server.url(),
                jwks_path
            ))
            .create();

        server
            .mock("GET", jwks_path)
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body("{\"keys\":[{\"kty\":\"RSA\",\"kid\":\"a\",\"n\":\"AQAB\",\"e\":\"AQAB\"}]}")
            .create();

        let mut config = test_config(format!("{}{}", server.url(), discovery_path));
        config.cookie_secret = "invalid".to_string();
        match Provider::new(config) {
            Ok(_) => panic!("provider init should fail on invalid cookie secret"),
            Err(err) => assert!(err.to_string().contains("cookie_secret")),
        }
    }

    #[test]
    fn exchange_code_for_session_accepts_valid_signed_token() {
        let set_cookie = exchange_with_signed_token(|nonce, issuer| {
            let claims = json!({
                "sub": "1234567890",
                "email": "user@example.com",
                "name": "User",
                "iss": issuer,
                "aud": "client-123",
                "iat": now_secs() as i64,
                "exp": (now_secs() + 300) as i64,
                "nonce": nonce
            });
            sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "test-key")
        });

        assert_ne!(set_cookie, "");
        let cookie_header = cookie_pair_from_set_cookie(&set_cookie);

        let (_server, provider) = setup_provider_server();
        assert!(provider.session_valid(Some(&cookie_header)));
        assert_eq!(
            provider.claim(Some(&cookie_header), "email"),
            "user@example.com"
        );
    }

    #[test]
    fn exchange_code_for_session_rejects_invalid_id_token_variants() {
        let expired = exchange_with_signed_token(|nonce, issuer| {
            let claims = json!({
                "sub": "1234567890",
                "email": "user@example.com",
                "iss": issuer,
                "aud": "client-123",
                "iat": now_secs() as i64,
                "exp": (now_secs() - 3600) as i64,
                "nonce": nonce
            });
            sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "test-key")
        });
        assert_eq!(expired, "");

        let wrong_aud = exchange_with_signed_token(|nonce, issuer| {
            let claims = json!({
                "sub": "1234567890",
                "email": "user@example.com",
                "iss": issuer,
                "aud": "wrong-client",
                "iat": now_secs() as i64,
                "exp": (now_secs() + 300) as i64,
                "nonce": nonce
            });
            sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "test-key")
        });
        assert_eq!(wrong_aud, "");

        let wrong_iss = exchange_with_signed_token(|nonce, _issuer| {
            let claims = json!({
                "sub": "1234567890",
                "email": "user@example.com",
                "iss": "http://wrong-issuer",
                "aud": "client-123",
                "iat": now_secs() as i64,
                "exp": (now_secs() + 300) as i64,
                "nonce": nonce
            });
            sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "test-key")
        });
        assert_eq!(wrong_iss, "");

        let wrong_signature = exchange_with_signed_token(|nonce, issuer| {
            let claims = json!({
                "sub": "1234567890",
                "email": "user@example.com",
                "iss": issuer,
                "aud": "client-123",
                "iat": now_secs() as i64,
                "exp": (now_secs() + 300) as i64,
                "nonce": nonce
            });
            sign_token_with_claims(&claims, FIXTURE_WRONG_RSA_PRIVATE_PEM, "test-key")
        });
        assert_eq!(wrong_signature, "");

        let missing_claims = exchange_with_signed_token(|nonce, _issuer| {
            let claims = json!({
                "email": "user@example.com",
                "iat": now_secs() as i64,
                "exp": (now_secs() + 300) as i64,
                "nonce": nonce
            });
            sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "test-key")
        });
        assert_eq!(missing_claims, "");
    }

    #[test]
    fn claims_size_limit_enforced() {
        let (_server, provider) = setup_provider_server();

        // Payload exceeding MAX_CLAIMS_BYTES should be rejected.
        let big_claims = json!({
            "sub": "123",
            "exp": (now_secs() + 60) as i64,
            "data": "x".repeat(4000)
        });
        let err = provider
            .create_session_cookie_from_claims(&big_claims)
            .unwrap_err();
        assert!(
            err.to_string().contains("exceeds 3072 bytes"),
            "expected size limit error, got: {err}"
        );

        // Payload just under the limit should succeed.
        // {"sub":"123","exp":9999999999,"data":"xx…"} — pad to stay under 3072.
        let overhead = serde_json::to_vec(&json!({"sub":"123","exp":9999999999u64,"data":""}))
            .unwrap()
            .len();
        let small_claims = json!({
            "sub": "123",
            "exp": (now_secs() + 60) as i64,
            "data": "x".repeat(MAX_CLAIMS_BYTES - overhead - 10)
        });
        assert!(
            provider
                .create_session_cookie_from_claims(&small_claims)
                .is_ok(),
            "claims under limit should succeed"
        );
    }

    #[test]
    fn jwks_refresh_on_unknown_kid() {
        let (mut server, provider, token_path) = setup_provider_server_with_fixture_jwks();

        // Parse the fixture JWKS to extract the RSA modulus/exponent.
        let fixture_jwks: Value = serde_json::from_str(FIXTURE_JWKS_JSON).unwrap();
        let n = fixture_jwks["keys"][0]["n"].as_str().unwrap();
        let e = fixture_jwks["keys"][0]["e"].as_str().unwrap();

        // Set up a new JWKS mock that returns both the original key and a "rotated-key".
        let rotated_jwks = json!({
            "keys": [
                {"kty":"RSA","alg":"RS256","kid":"test-key","n":n,"e":e,"use":"sig"},
                {"kty":"RSA","alg":"RS256","kid":"rotated-key","n":n,"e":e,"use":"sig"}
            ]
        });
        server
            .mock("GET", "/jwks")
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(rotated_jwks.to_string())
            .create();

        // Perform the full exchange flow with a token signed using kid "rotated-key".
        // The first lookup will miss (cache only has "test-key"), triggering a JWKS
        // refresh that picks up "rotated-key".
        let start = provider
            .authorization_url("/protected")
            .expect("auth start should work");
        let state = query_param(&start.url, "state").expect("state must exist");
        let nonce = query_param(&start.url, "nonce").expect("nonce must exist");

        let claims = json!({
            "sub": "1234567890",
            "email": "user@example.com",
            "iss": server.url(),
            "aud": "client-123",
            "iat": now_secs() as i64,
            "exp": (now_secs() + 300) as i64,
            "nonce": nonce
        });
        let token = sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "rotated-key");

        server
            .mock("POST", token_path.as_str())
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(format!(
                "{{\"id_token\":\"{token}\",\"access_token\":\"abc\",\"token_type\":\"Bearer\"}}"
            ))
            .create();

        let callback_url = format!("/oidc/callback?code=auth-code&state={state}");
        let cookie_header = cookie_pair_from_set_cookie(&start.state_set_cookie);
        let result =
            provider.exchange_code_for_session("auth-code", &callback_url, Some(&cookie_header));

        assert_ne!(result, "", "exchange should succeed after JWKS refresh");
    }

    #[test]
    fn jwks_exponential_backoff() {
        let (mut server, provider) = setup_provider_server();

        // Replace the JWKS endpoint with one that returns 500.
        server
            .mock("GET", "/jwks")
            .with_status(500)
            .create();

        // Force the cache to be expired so refresh is attempted.
        {
            let mut cache = provider.jwks_cache.lock().unwrap();
            cache.expires_at = 0;
        }

        // First failure: refresh_failures goes from 0 to 1, backoff = 2^0 = 1s.
        let _ = provider.refresh_jwks(true);
        {
            let cache = provider.jwks_cache.lock().unwrap();
            assert_eq!(cache.refresh_failures, 1, "first failure should set count to 1");
            // backoff_until should be roughly now + 1
            let expected_backoff = 1u64; // 2^0
            let drift = cache.backoff_until.saturating_sub(now_secs());
            assert!(
                drift <= expected_backoff + 1,
                "first backoff should be ~1s, got drift {drift}"
            );
        }

        // Reset backoff_until and expires_at so we can trigger another failure.
        {
            let mut cache = provider.jwks_cache.lock().unwrap();
            cache.backoff_until = 0;
            cache.expires_at = 0;
        }

        // Second failure: refresh_failures goes from 1 to 2, backoff = 2^1 = 2s.
        let _ = provider.refresh_jwks(true);
        {
            let cache = provider.jwks_cache.lock().unwrap();
            assert_eq!(cache.refresh_failures, 2, "second failure should set count to 2");
            let expected_backoff = 2u64; // 2^1
            let drift = cache.backoff_until.saturating_sub(now_secs());
            assert!(
                drift <= expected_backoff + 1,
                "second backoff should be ~2s, got drift {drift}"
            );
        }

        // Reset and trigger a third failure: backoff = 2^2 = 4s.
        {
            let mut cache = provider.jwks_cache.lock().unwrap();
            cache.backoff_until = 0;
            cache.expires_at = 0;
        }

        let _ = provider.refresh_jwks(true);
        {
            let cache = provider.jwks_cache.lock().unwrap();
            assert_eq!(cache.refresh_failures, 3, "third failure should set count to 3");
            let expected_backoff = 4u64; // 2^2
            let drift = cache.backoff_until.saturating_sub(now_secs());
            assert!(
                drift <= expected_backoff + 1,
                "third backoff should be ~4s, got drift {drift}"
            );
        }
    }

    #[test]
    fn non_object_cookie_payload_rejected() {
        let (_server, provider) = setup_provider_server();

        // Encrypt a JSON array — should be rejected by the as_object() check.
        let array_value = provider
            .cookie_cipher
            .encrypt_json(&json!(["not", "an", "object"]))
            .expect("encrypt should succeed");
        let cookie_header = format!("{}={array_value}", provider.config.cookie_name);
        assert!(
            !provider.session_valid(Some(&cookie_header)),
            "array payload should not be a valid session"
        );

        // Encrypt a plain string — also not an object.
        let string_value = provider
            .cookie_cipher
            .encrypt_json(&json!("just a string"))
            .expect("encrypt should succeed");
        let cookie_header = format!("{}={string_value}", provider.config.cookie_name);
        assert!(
            !provider.session_valid(Some(&cookie_header)),
            "string payload should not be a valid session"
        );
    }

    #[test]
    fn handle_backend_request_login_redirect() {
        let (_server, provider) = setup_provider_server();

        let resp = provider.handle_backend_request("/app/dashboard", None);
        match resp {
            OidcBackendResponse::LoginRedirect {
                location,
                state_set_cookie,
            } => {
                assert!(location.contains("response_type=code"));
                assert!(location.contains("client_id=client-123"));
                assert!(!state_set_cookie.is_empty());
            }
            other => panic!("expected LoginRedirect, got {other:?}"),
        }
    }

    #[test]
    fn handle_backend_request_callback_invalid_state() {
        let (_server, provider) = setup_provider_server();

        // Callback with no state cookie → 403
        let resp =
            provider.handle_backend_request("/oidc/callback?code=abc&state=bogus", None);
        match resp {
            OidcBackendResponse::Error { status: 403 } => {}
            other => panic!("expected Error 403, got {other:?}"),
        }
    }

    #[test]
    fn handle_backend_request_callback_missing_code() {
        let (_server, provider) = setup_provider_server();

        // Callback with no code parameter → 403
        let resp = provider.handle_backend_request("/oidc/callback?state=abc", None);
        match resp {
            OidcBackendResponse::Error { status: 403 } => {}
            other => panic!("expected Error 403, got {other:?}"),
        }
    }

    #[test]
    fn handle_backend_request_callback_success() {
        let (mut server, provider, token_path) = setup_provider_server_with_fixture_jwks();

        let start = provider
            .authorization_url("/protected?x=1")
            .expect("auth start should work");
        let state = query_param(&start.url, "state").expect("state must exist");
        let nonce = query_param(&start.url, "nonce").expect("nonce must exist");

        let claims = json!({
            "sub": "1234567890",
            "email": "user@example.com",
            "iss": server.url(),
            "aud": "client-123",
            "iat": now_secs() as i64,
            "exp": (now_secs() + 300) as i64,
            "nonce": nonce
        });
        let token = sign_token_with_claims(&claims, FIXTURE_RSA_PRIVATE_PEM, "test-key");

        server
            .mock("POST", token_path.as_str())
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(format!(
                "{{\"id_token\":\"{token}\",\"access_token\":\"abc\",\"token_type\":\"Bearer\"}}"
            ))
            .create();

        let callback_url = format!("/oidc/callback?code=auth-code&state={state}");
        let cookie_header = cookie_pair_from_set_cookie(&start.state_set_cookie);

        let resp =
            provider.handle_backend_request(&callback_url, Some(&cookie_header));
        match resp {
            OidcBackendResponse::CallbackSuccess {
                location,
                session_set_cookie,
            } => {
                assert_eq!(location, "/protected?x=1");
                assert!(!session_set_cookie.is_empty());
                assert!(session_set_cookie.contains("HttpOnly"));
            }
            other => panic!("expected CallbackSuccess, got {other:?}"),
        }
    }

    #[test]
    fn redirect_uri_path_extracted_correctly() {
        let (_server, provider) = setup_provider_server();
        assert_eq!(provider.redirect_uri_path(), "/oidc/callback");
    }
}
